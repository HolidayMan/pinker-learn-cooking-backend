С первого взгяда все достаточно просто получается, если заглянуть в `models.py`. 
Но это только на первый взгляд. 

Дружок, попрошу тебя обратить внимание на *many-to-many* отношение между Dish и Ingredients. 
Если ты посмотришь, то поймешь, что автор этого кода с синдромом повышенной гениальности и сделал эту связь через еще одну модель (ну и зачем он так все усложнил?) 
Ответ - ради большей гибкости. Получилось ли у него? Да, но работы из-за этого больше, чем было бы в более простом варианте - прост добавлять новый ингридиент к каждому блюду и наплевать на их имена. 
Шизик, одним словом. Теперь нужно запариваться с админкой намного больше, чем пришлось бы. А также появились некоторые сложности с доступом к ингридиентам блюд. 
Что за проблемы? А вот имея объект модели Dish, как бы ты получал относящиеся к ней Ingredients? `dish.ingredients`? А вот хер тебе. 
Теперь тебе придется писать вот такую гениальщину:

> `DishIngredient.objects.filter(dish=dish)`

Да, это сильно все усложняет, но что поделать. *Зато гибко-то как!* 
И да, не забывай, что эта строка вернет тебе список DishIngredient'ов, поэтому доступ к названию ингридиента будет происходить через `dishingredient.ingredient.name`))))
Наслаждайся, бл*ть.

Теперь о сериалайзерах. Заметь, IngredientSerializer является наследником ModelSerializer, но реализует сериализацию DishIngredient. 
Не, ну а че, именно эта модель в данном случае описывает ингридиенты блюд. Вроде гибко, а кода в разы больше писать приходится, да? 
Понимаю. Я сам уже не так уж и доволен данной задумкой, но вроде не сильно мешает, так что терпим.
